
\chapter{Ausblick}%
\label{cha:ausblick}




\section{Nächste Schritte}%
\label{sec:naeste_schritte}

\subsection{Entwicklungswerkzeuge als Docker Container}%
\label{sub:developmenthost}

Es wäre sinnvoll die Entwicklungstools in einem oder mehrere Docker
container vorkonfiguiert zur verfügug zu stellen. Hierzu zählen unter anderem:

\begin{description}
    \item[Eclipse] Vorkonfiguriertes Eclipse inclusieve Plugins, Cross-Compile
        und Remote debugging Einstellungen.
    \item[QT5] Vorkonfiguiertes QT mit Crosscompile und Remot Debugging
    \item TFTboot und NFSROOT Server in einem Container vorkonfiguriert bereitstellen
\end{description}


\subsection{Erweiterung der Scripte}%
\label{sub:erweiterung_der_scripte}

Das \textit{run.sh} script sollte so erweitert werden, das es \glq post\grq
oder \glq pre\grq Aufgaben vor oder nach dem aufrufen der \textit{dockerjobs.sh}
durchführt oder andere postbuild oder prebuild scripte aufruft. Denkbar wären:

\begin{itemize}
    \item Kopieren des zImages und \ac{DTB} in das \textit{TFT-boot} Verzeichnis
    \item Kopieren und extrahieren des rootfs in das nfs-rootfs Verzeichnis
\end{itemize}


Das \textit{run.sh} script erzeugt das \textit{dockerjobs.sh} Script sollte dem
\textit{run.sh} script parameter übergeben werden. Anschließend startet das
\textit{run.sh} script den Docker Container in definierter Version
(gesetzt über Parameter oder direkt innerhalb des run.sh scripts). Das
\textit{dockerjobs.sh} wird innerhalb docker durch das Image aufgerufen und
enthält alle Aufgaben, welche durch den Container in Batchbetrieb erfüllt werden
sollen. Das \textit{dockerjobs.sh} Script lässt sich manuell erweitern bzw,
erstellen. Es wird nur überschrieben, wenn dem \textit{run.sh}
Ausführungs\-befehle übergeben werden.



\section{Security}%
Gerade zu Beginn der Entwicklung bietet sich an, zunächst auf viele
Sicherheit\-funktionen zu verzichten, da der gesamte Entwicklungs\-prozess
bereits komplex ist und ausreichend potentielle Fehlerquellen besitzt.
\\

Dennoch ist mindestens zum Ende eines Projektes, vor Veröffentlichung, das
Sicherheits\-konzept überarbeitet werden.
So müssen beispielsweise nachfolgende Themen bewertet und bearbeitet werden
\label{sec:security}

\begin{itemize}
    \item Linux Kernel härten
    \item SELinux
    \item Gesamt System härten
    \item SMACK
    \item Benutzer, Passwörter, Zugrifffsrechte, ACLs
    \item Netzwerkschnittstellen und Kommunikation absichern. Beispielweise
        durch verschlüsselte Datenübertragung
    \item Debugging, Flashing, Tracing Schnittstellen entfernen oder
        einschränken
\end{itemize}


\section{Lizenzen}%
\label{sec:lizenzen}

Eine wichtiges Thema ist die Lizensierung neuer Softwarekomponenten, welche
zusammen mit Open-Source paketen (i.d.R. mindestens dem Linux Kernel) genutzt
werden und mit diesen Kompatible sein muss. So muss ich über folgende
Kombinationen gedanken gemacht werden.

Lizenverwaltung und Kompatibilität von:
\begin{itemize}
    \item Neuen Sofwarekomponenten
    \item Bestehenden  Sofwarekomponenten
    \item Verwendeten / Eingebundenen Softwarepaketen, z.B. über genutzte
        Metadatan Layer aus Community Quellen.
\end{itemize}


\section{Kerneldebugging, Kerneltracing, Profiling, Binary-Analyse}
\label{sec:kerneldebugging_kerneltracing_profiling_binaryanalyse}
Früher oder später wird es erforderlich sein, sie mit Themen des
Kerneldebugging, Kerneltracing, Profiling, Binary-Analyse und ähnlichen Themen
zu beschäftigen. Sie es aufgrund unerklärlicher Fehler oder etwa aus Preformance
Gründen. Hierzu stehen verschiedene Tools und Techniken bereit welche gelistet
und anhand einfacher Beispiele beschrieben sind unter \cite[Kapitel 5 ]\cite{Gonzalez2018:Embedded_Linux_Development_Using_Yocto_Project_Cookbook_2nd}


\section{Alternativen zu Yocto}%
\label{sec:Alternativen zu Yocto}

Neben \textit{bitbake} der Yocto und  Openembedded Community gibt es andere
Buildumgebungen um Linuxdistributionen gezielt für eine Hardware zu paketieren
und aus Quelldateien zu compelieren. Bitbake ist dabei die Komplzierteste aber
gleichzeitig auch das flexibelste Tool mit der größten Weiterentwicklung aus der
Community und der aktuell größten unterstützung und akzeptanz aus bzw in der
Wirtschaft.
\\
Alternativen sind beispielsweise:

\begin{description}
    \item[Buildroot] Eine sehr einfache und schlankes  Buildtool  mit wenig
        Flexibilität. \cite{buildroot}
    \item[ptxdist] In der Funktionsweise ähnlich wie Bitbake mit gleichen
        Ansätzen. In der Anwendung einfacher jedoch weniger flexible. Es setzt im
        Gegensatz auf Makefiles auf, anstelle von Python und Shell-Scripten wie
        es Bitbake tut. Quelle: \cite{ptxdist}
\end{description}








